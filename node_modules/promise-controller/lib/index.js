'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @ignore
 */
var defaults = require('./defaults');

/**
 * @typicalname pc
 */

var PromiseController = function () {
  /**
   * Creates promise controller. Unlike original Promise, it does not immediately call any function.
   * Instead it has [.call()](#PromiseController+call) method that calls provided function
   * and stores `resolve / reject` methods for future access.
   *
   * @param {Options} [options]
   */
  function PromiseController(options) {
    _classCallCheck(this, PromiseController);

    this._options = Object.assign({}, defaults, options);
    this._resolve = null;
    this._reject = null;
    this._isPending = false;
    this._isFulfilled = false;
    this._isRejected = false;
    this._value = undefined;
    this._promise = null;
    this._timer = null;
  }

  /**
   * Returns promise itself.
   *
   * @returns {Promise}
   */


  _createClass(PromiseController, [{
    key: 'call',


    /**
     * This method executes `fn` and returns promise. While promise is pending all subsequent calls of `.call(fn)`
     * will return the same promise. To fulfill that promise you should use `.resolve() / .reject()` methods.
     * If `fn` itself returns promise, then external promise is attached to it and fulfills together.
     *
     * @param {Function} fn
     * @returns {Promise}
     */
    value: function call(fn) {
      if (!this._isPending) {
        this.reset();
        this._createPromise();
        this._createTimer();
        this._callFn(fn);
      }
      return this._promise;
    }

    /**
     * Resolves pending promise with specified `value`.
     *
     * @param {*} [value]
     */

  }, {
    key: 'resolve',
    value: function resolve(value) {
      if (this._isPending) {
        if (isPromise(value)) {
          this._tryAttachToPromise(value);
        } else {
          this._settle(value);
          this._isFulfilled = true;
          this._resolve(value);
        }
      }
    }

    /**
     * Rejects pending promise with specified `value`.
     *
     * @param {*} [value]
     */

  }, {
    key: 'reject',
    value: function reject(value) {
      if (this._isPending) {
        this._settle(value);
        this._isRejected = true;
        this._reject(value);
      }
    }

    /**
     * Resets to initial state.
     * If promise is pending it will be rejected with error: "Promise rejected by reset".
     */

  }, {
    key: 'reset',
    value: function reset() {
      if (this._isPending) {
        this.reject(new Error(this._options.resetReason));
      }
      this._promise = null;
      this._isPending = false;
      this._isFulfilled = false;
      this._isRejected = false;
      this._value = undefined;
      this._clearTimer();
    }

    /**
     * Re-assign one or more options.
     *
     * @param {Options} options
     */

  }, {
    key: 'configure',
    value: function configure(options) {
      Object.assign(this._options, options);
    }
  }, {
    key: '_createPromise',
    value: function _createPromise() {
      var _this = this;

      this._promise = new Promise(function (resolve, reject) {
        _this._isPending = true;
        _this._resolve = resolve;
        _this._reject = reject;
      });
    }
  }, {
    key: '_handleTimeout',
    value: function _handleTimeout() {
      var timeoutReason = this._options.timeoutReason;

      if (typeof timeoutReason === 'function') {
        timeoutReason();
      } else {
        var error = typeof timeoutReason === 'string' ? new Error(timeoutReason) : timeoutReason;
        this.reject(error);
      }
    }
  }, {
    key: '_createTimer',
    value: function _createTimer() {
      var _this2 = this;

      if (this._options.timeout) {
        this._timer = setTimeout(function () {
          return _this2._handleTimeout();
        }, this._options.timeout);
      }
    }
  }, {
    key: '_clearTimer',
    value: function _clearTimer() {
      if (this._timer) {
        clearTimeout(this._timer);
        this._timer = null;
      }
    }
  }, {
    key: '_settle',
    value: function _settle(value) {
      this._isPending = false;
      this._value = value;
      this._clearTimer();
    }
  }, {
    key: '_callFn',
    value: function _callFn(fn) {
      if (typeof fn === 'function') {
        try {
          var result = fn();
          this._tryAttachToPromise(result);
        } catch (e) {
          this.reject(e);
        }
      }
    }
  }, {
    key: '_tryAttachToPromise',
    value: function _tryAttachToPromise(p) {
      var _this3 = this;

      if (isPromise(p)) {
        p.then(function (value) {
          return _this3.resolve(value);
        }, function (e) {
          return _this3.reject(e);
        });
      }
    }
  }, {
    key: 'promise',
    get: function get() {
      return this._promise;
    }

    /**
     * Returns value with that promise was settled (fulfilled or rejected).
     *
     * @returns {*}
     */

  }, {
    key: 'value',
    get: function get() {
      return this._value;
    }

    /**
     * Returns true if promise is pending.
     *
     * @returns {Boolean}
     */

  }, {
    key: 'isPending',
    get: function get() {
      return this._isPending;
    }

    /**
     * Returns true if promise is fulfilled.
     *
     * @returns {Boolean}
     */

  }, {
    key: 'isFulfilled',
    get: function get() {
      return this._isFulfilled;
    }

    /**
     * Returns true if promise rejected.
     *
     * @returns {Boolean}
     */

  }, {
    key: 'isRejected',
    get: function get() {
      return this._isRejected;
    }

    /**
     * Returns true if promise is fulfilled or rejected.
     *
     * @returns {Boolean}
     */

  }, {
    key: 'isSettled',
    get: function get() {
      return this._isFulfilled || this._isRejected;
    }
  }]);

  return PromiseController;
}();

function isPromise(p) {
  return p && typeof p.then === 'function';
}

module.exports = PromiseController;